STATUS SUMMARY
  the theory of putting lazy sequences in channels, and then writing to buffers seems to work
  need to re-build the ugen stuff so it can read inputs from channels and buffers

  terminate predicate is a dirty hack... there should be a (terminate) event in the event scheduling 
  mechanism. This would allow the predicate to be automatically generated.


PLANS
  ugens used as control inputs for other ugens should be written to channels
    Channels need to be accessed by index instead of name so we can guarantee order of execution

  need to completely re-write ugen stuff...
    can't compose ugens
      eg. (sin (sin ...))
    can't pipe from one channel to another
      eg. (mul-add (sin ..) 0.5 0) ; pipe the output of the sin into the mul-add
    can't use ugens as controls

  need to create some event scheduling mechanism
    needs to be included in the event loop code (ie. in music.scheduling.core)


PLAYGROUND FILES
  music.playground  - basic initial creation of ugen lazy sequences for sin/sqr/saw/tri
  music.playground2 - basic test of music.synthesis.buffers
  music.playground3 - empty


ARCHITECTURE
  ugens are modeled as lazy sequences, with control parameters being read dynamically either from other ugens or constants

  these lazy sequences are stored in "Channels" which are themselves stored in a vector called the CHANNEL_BANK
    Channels are referenced by index
    each channel contains two pieces of data
      a sequence (or nil)
        this represents the samples generated by this channel.
        if it's nil, then the channel is currently empty
        if the sequence ever generates the value nil, then the sequence is destroyed and replaced with nil
      a target buffer index (optional)
        if the channel has a target buffer index, as each sample is calculated it is added to the buffer specified by that index.
        if the channel is to be routed to the final output, it should be routed to buffer 0 for left or 1 for right
      channels are recalculated in the order defined by their syntax, so a given channel should only depend on channels with lower indexes than themselves

  Buffers are used for mixing the output of Channels and/or piping the results elsewhere. They are stored in an vector called BUFFER_BANK
    Buffers are only accessed by index
    the first two buffers are used for left and right audio
    a Buffer contains two pieces of data
      a atom containing a vector
        this represents the current values of all the channels which write to this buffer
        when the Buffer is queried for it's value, the average of the values in this vector are returned.
      an target buffer index (optional)
    after the Channels have all written their values to the buffers, the buffers then do the same (each writes it's value into the buffer associated with it's target buffer index)
      this occurs in increasing index order, so buffers can only write to Other buffers whose index is higher.

  To generate the sound we step through the sequences sample by sample, performing the following steps for each sample:
    drop the first value of each Channel's sequence to trigger calculation of the next sample
    clear the old values of the Buffers
    write values from channels to buffers
    write values from buffers to buffers
  This loop occurs in fixed size batches with the values of buffers 0 and 1 being collected.
  when the batch is finished, the samples that were collected from buffers 0 and 1 are written to the output file

  This continues until a given termination condition is reached whereupon the samples are written to the output file.
